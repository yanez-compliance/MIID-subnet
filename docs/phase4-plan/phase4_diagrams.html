<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MIID Phase 4: Image Variations Pipeline</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background-color: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
        }
        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 1.1em;
        }
        .mermaid {
            text-align: center;
            overflow-x: auto;
        }
        .mermaid svg {
            max-width: 100%;
            height: auto;
        }
        .toggle-buttons {
            text-align: center;
            margin-bottom: 30px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
        }
        .toggle-btn {
            background-color: #f8f9fa;
            border: 2px solid #6366f1;
            color: #6366f1;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
        }
        .toggle-btn:hover {
            background-color: #eef2ff;
        }
        .toggle-btn.active {
            background-color: #6366f1;
            color: white;
        }
        .description {
            margin-top: 30px;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #6366f1;
        }
        .description h3 {
            color: #6366f1;
            margin-top: 0;
        }
        .description ul {
            margin: 0;
            padding-left: 20px;
        }
        .description li {
            margin-bottom: 8px;
        }
        .spec-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        .spec-table th, .spec-table td {
            border: 1px solid #ddd;
            padding: 10px;
            text-align: left;
        }
        .spec-table th {
            background-color: #6366f1;
            color: white;
        }
        .spec-table tr:nth-child(even) {
            background-color: #f8f9fa;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>MIID Subnet Phase 4: Image Variations</h1>
        <p class="subtitle">Synthetic Image Variation Generation for KYC Verification</p>

        <div class="toggle-buttons">
            <button id="overviewBtn" class="toggle-btn active" onclick="showOverview()">Overview</button>
            <button id="sandboxBtn" class="toggle-btn" onclick="showSandbox()">Sandbox</button>
            <button id="detailedBtn" class="toggle-btn" onclick="showDetailed()">Detailed Flow</button>
            <button id="protocolBtn" class="toggle-btn" onclick="showProtocol()">Protocol</button>
            <button id="validationBtn" class="toggle-btn" onclick="showValidation()">Validation Flow</button>
            <button id="databaseBtn" class="toggle-btn" onclick="showDatabase()">Database Schema</button>
            <button id="s3Btn" class="toggle-btn" onclick="showS3()">S3 Storage</button>
            <button id="drandBtn" class="toggle-btn" onclick="showDrand()">Drand Timelock</button>
        </div>

        <!-- Overview Diagram -->
        <div id="overviewDiagram" class="mermaid">
flowchart LR
    subgraph Validator["Validator (Online)"]
        DB["Base Image<br/>Database"]
        KAV["KAV + Reputation<br/>SET WEIGHTS"]
    end

    subgraph Miners["Miners"]
        MG["Image Generator<br/>(Any Model)"]
        S3UP["Encrypt & Upload<br/>to S3"]
    end

    subgraph PostVal["Post-Validation (After Cycle)"]
        PV["Face Match<br/>Quality Check<br/>Cheat Detection"]
        REP["Update Reputation<br/>for Next Cycle"]
    end

    DB -->|Base Image| MG
    MG -->|Generate 3-5| S3UP
    S3UP -->|S3 Refs| KAV
    KAV -.->|S3 Refs stored| PV
    PV --> REP
    REP -.->|Used in Next Cycle| KAV

    style DB fill:#e0e7ff,stroke:#6366f1
    style KAV fill:#fee2e2,stroke:#ef4444
    style MG fill:#fef3c7,stroke:#f59e0b
    style S3UP fill:#fef3c7,stroke:#f59e0b
    style PV fill:#d1fae5,stroke:#10b981
    style REP fill:#d1fae5,stroke:#10b981
        </div>

        <!-- Sandbox Diagram -->
        <div id="sandboxDiagram" class="mermaid" style="display: none;">
flowchart LR
    subgraph Validator["VALIDATOR (Phase4-C1-Sandbox)"]
        FOLDER["./base_images/<br/>folder"]
        LOAD["Load Random<br/>Image"]
        VARSEL["Select 2-4 Variations<br/>(type + intensity)"]
        SYNAPSE["Create Synapse<br/>+ ImageRequest"]
        KAV["KAV Validation<br/>SET WEIGHTS"]
        UPLOAD["Upload to<br/>YANEZ Server"]
    end

    subgraph Miner["MINER"]
        DECODE["Decode Base64<br/>Image"]
        GEN["generate_variations()<br/>[SANDBOX:<br/>returns copies]"]
        PATHSIG["Generate<br/>path_signature"]
        SIGN["Sign with<br/>wallet.hotkey"]
        ENCRYPT["tlock.encrypt()<br/>72 min reveal"]
        S3UP["Upload to S3<br/>yanez-miid-sn54"]
        RESPOND["Return<br/>S3Submissions"]
    end

    subgraph YANEZ["YANEZ (Post-Validation)"]
        DOWNLOAD["Download from S3"]
        DECRYPT["Decrypt with<br/>drand beacon"]
        VALIDATE["Face Match<br/>Quality Check<br/>Intensity Check"]
        REPUPDATE["Update Reputation<br/>for Next Cycle"]
    end

    FOLDER --> LOAD
    LOAD --> VARSEL
    VARSEL --> SYNAPSE
    SYNAPSE -->|"base_image +<br/>variation_requests[]"| DECODE
    DECODE --> GEN
    GEN --> PATHSIG
    PATHSIG --> SIGN
    SIGN --> ENCRYPT
    ENCRYPT --> S3UP
    S3UP --> RESPOND
    RESPOND -->|"s3_key, hash,<br/>signature, path_signature"| KAV
    KAV --> UPLOAD
    UPLOAD -.->|"Results JSON<br/>Phase4-C1-Sandbox"| DOWNLOAD
    DOWNLOAD --> DECRYPT
    DECRYPT --> VALIDATE
    VALIDATE --> REPUPDATE

    style FOLDER fill:#e0e7ff,stroke:#6366f1
    style LOAD fill:#e0e7ff,stroke:#6366f1
    style VARSEL fill:#e0e7ff,stroke:#6366f1
    style SYNAPSE fill:#e0e7ff,stroke:#6366f1
    style KAV fill:#fee2e2,stroke:#ef4444
    style UPLOAD fill:#e0e7ff,stroke:#6366f1
    style DECODE fill:#fef3c7,stroke:#f59e0b
    style GEN fill:#fef3c7,stroke:#f59e0b
    style PATHSIG fill:#fef3c7,stroke:#f59e0b
    style SIGN fill:#fef3c7,stroke:#f59e0b
    style ENCRYPT fill:#fef3c7,stroke:#f59e0b
    style S3UP fill:#fef3c7,stroke:#f59e0b
    style RESPOND fill:#fef3c7,stroke:#f59e0b
    style DOWNLOAD fill:#d1fae5,stroke:#10b981
    style DECRYPT fill:#d1fae5,stroke:#10b981
    style VALIDATE fill:#d1fae5,stroke:#10b981
    style REPUPDATE fill:#d1fae5,stroke:#10b981
        </div>

        <!-- Detailed Flow Diagram -->
        <div id="detailedDiagram" class="mermaid" style="display: none;">
flowchart TB
    subgraph Input["Input (Validator)"]
        DB["Base Image Database<br/>(Pre-loaded images)"]
        PROMPT["Dynamic Selection<br/>2-4 types √ó intensity<br/>(light/medium/far)"]
    end

    subgraph Synapse["IdentitySynapse (Request)"]
        BASE["base_image (Base64)"]
        TYPES["variation_requests[]<br/>(type + intensity)"]
        DRAND["target_drand_round<br/>(72 min reveal)"]
        CHID["challenge_id<br/>(with validator hotkey)"]
    end

    subgraph Miner["Miner Processing"]
        DECODE["Decode Base Image"]
        GEN["Generate Variations<br/>(Any Model)"]
        SIGN["Sign with Wallet<br/>(sign_message)"]
        ENCRYPT["Encrypt with Drand<br/>(tlock.encrypt)"]
        UPLOAD["Upload to S3"]
    end

    subgraph Response["Synapse Response (NOT images)"]
        S3KEY["s3_key (path)"]
        HASH["image_hash (SHA256)"]
        SIG["signature (wallet)"]
        PSIG["path_signature<br/>(prevents path hijacking)"]
    end

    subgraph OnlineVal["ONLINE VALIDATION (Immediate)"]
        KAV["Validate KAV<br/>(Name/DOB/Address)"]
        PREV_REP["Get Previous<br/>Cycle Reputation"]
        WEIGHT["SET WEIGHTS<br/>ON-CHAIN NOW"]
        STORE["Store S3 Refs<br/>for Post-Validation"]
    end

    subgraph PostVal["POST-VALIDATION (After Cycle + Drand)"]
        DOWNLOAD["Download from S3"]
        DECRYPT["Decrypt with<br/>Drand Beacon"]
        VERIFY["Verify Signature"]
        FACE["Face Matching<br/>(ArcFace >= 0.8)"]
        QUALITY["Quality Check"]
        CHEAT["Cheat Detection"]
    end

    subgraph RepUpdate["REPUTATION UPDATE (For Next Cycle)"]
        SCORE["Calculate<br/>Post-Validation Score"]
        REP["Update Reputation<br/>for Cycle N+1"]
    end

    DB --> BASE
    PROMPT --> TYPES
    BASE --> Synapse
    TYPES --> Synapse
    DRAND --> Synapse

    Synapse -->|"120s timeout"| DECODE
    DECODE --> GEN
    GEN --> SIGN
    SIGN --> ENCRYPT
    ENCRYPT --> UPLOAD

    UPLOAD --> S3KEY
    UPLOAD --> HASH
    UPLOAD --> SIG
    Response -->|"Return to Validator"| KAV

    KAV --> PREV_REP
    PREV_REP --> WEIGHT
    KAV --> STORE

    STORE -.->|"After Cycle Ends"| DOWNLOAD
    DOWNLOAD --> DECRYPT
    DECRYPT --> VERIFY
    VERIFY -->|"Valid"| FACE
    VERIFY -->|"Invalid"| REJECT["Reject"]
    FACE -->|">= 0.8"| QUALITY
    FACE -->|"< 0.8"| REJECT
    QUALITY --> CHEAT
    CHEAT --> SCORE

    SCORE --> REP
    REP -.->|"Used in<br/>Next Cycle"| PREV_REP

    style DB fill:#e0e7ff,stroke:#6366f1
    style PROMPT fill:#e0e7ff,stroke:#6366f1
    style BASE fill:#f3e8ff,stroke:#a855f7
    style TYPES fill:#f3e8ff,stroke:#a855f7
    style DRAND fill:#f3e8ff,stroke:#a855f7
    style DECODE fill:#fef3c7,stroke:#f59e0b
    style GEN fill:#fef3c7,stroke:#f59e0b
    style SIGN fill:#fef3c7,stroke:#f59e0b
    style ENCRYPT fill:#fef3c7,stroke:#f59e0b
    style UPLOAD fill:#fef3c7,stroke:#f59e0b
    style S3KEY fill:#fce7f3,stroke:#ec4899
    style HASH fill:#fce7f3,stroke:#ec4899
    style SIG fill:#fce7f3,stroke:#ec4899
    style KAV fill:#d1fae5,stroke:#10b981
    style PREV_REP fill:#d1fae5,stroke:#10b981
    style STORE fill:#d1fae5,stroke:#10b981
    style DOWNLOAD fill:#dbeafe,stroke:#3b82f6
    style DECRYPT fill:#dbeafe,stroke:#3b82f6
    style VERIFY fill:#dbeafe,stroke:#3b82f6
    style FACE fill:#dbeafe,stroke:#3b82f6
    style QUALITY fill:#dbeafe,stroke:#3b82f6
    style CHEAT fill:#dbeafe,stroke:#3b82f6
    style SCORE fill:#fef3c7,stroke:#f59e0b
    style REP fill:#fef3c7,stroke:#f59e0b
    style WEIGHT fill:#fee2e2,stroke:#ef4444
    style REJECT fill:#fecaca,stroke:#dc2626
        </div>

        <!-- Protocol Diagram -->
        <div id="protocolDiagram" class="mermaid" style="display: none;">
classDiagram
    class IdentitySynapse {
        +List~List~str~~ identity
        +str query_template
        +Optional~Dict~ variations
        +Optional~ImageRequest~ image_request
        +Optional~List~S3Submission~~ s3_submissions
    }

    class VariationRequest {
        +str type
        +str intensity
        +str description
        +str detail
    }

    class ImageRequest {
        +str base_image
        +str image_filename
        +List~VariationRequest~ variation_requests
        +int target_drand_round
        +int reveal_timestamp
        +str challenge_id
    }

    class S3Submission {
        +str s3_key
        +str image_hash
        +str signature
        +str variation_type
        +str path_signature
    }

    class UAVData {
        +str address
        +str label
        +Optional~float~ latitude
        +Optional~float~ longitude
    }

    class SeedData {
        +List~str~ names
        +List~str~ addresses
        +List~str~ dobs
    }

    IdentitySynapse --> ImageRequest : "Validator ‚Üí Miner"
    IdentitySynapse --> S3Submission : "Miner ‚Üí Validator"
    ImageRequest --> VariationRequest : "2-4 per challenge"
    IdentitySynapse --> UAVData : "Phase 3"
    IdentitySynapse --> SeedData : "Phase 3"

    note for IdentitySynapse "Extended Bittensor Synapse<br/>for MIID subnet"
    note for VariationRequest "Dynamic selection:<br/>pose_edit, lighting_edit,<br/>expression_edit, background_edit<br/>√ó light/medium/far"
    note for ImageRequest "challenge_id includes<br/>validator hotkey for uniqueness"
    note for S3Submission "path_signature prevents<br/>other miners writing to path"
        </div>

        <!-- Validation Flow Diagram -->
        <div id="validationDiagram" class="mermaid" style="display: none;">
sequenceDiagram
    autonumber
    participant V as Validator
    participant M as Miner
    participant S3 as S3 (yanez-miid-sn54)
    participant DR as Drand Network
    participant PV as YANEZ Post-Validator
    participant DB as Database

    Note over V: STAGE 1: ONLINE VALIDATION (Immediate)

    Note over V: Select base image + 2-4 variation types
    V->>V: Create ImageRequest with variation_requests[]<br/>(type + intensity) + challenge_id

    V->>M: Send IdentitySynapse<br/>(base_image, variation_requests[], 72min reveal)

    Note over M: 120 second timeout - Generate & Upload
    M->>M: Decode base image
    M->>M: Generate 2-4 variations
    M->>M: Derive path_signature from challenge_id
    M->>M: Sign with wallet (sign_message)
    M->>M: Encrypt with drand timelock
    M->>S3: Upload to /{challenge_id}/{hotkey}/{path_signature}/

    M->>V: Return S3Submissions[]<br/>(s3_keys, hashes, signatures, path_signature)

    Note over V: Online: KAV + Previous Reputation
    V->>V: Validate KAV (Name/DOB/Address)
    V->>DB: Get previous cycle reputation
    V->>V: Calculate weight = f(KAV, prev_reputation)
    V->>V: SET WEIGHTS ON-CHAIN NOW
    V->>DB: Store S3 refs + requested_variations for YANEZ

    Note over DR,PV: STAGE 2: POST-VALIDATION (After ~72 min)

    DR->>DR: Drand beacon published (1 Bittensor epoch)
    PV->>S3: Download encrypted images
    PV->>PV: Decrypt with drand beacon
    PV->>PV: Verify signatures + path_signature

    loop For each submission
        PV->>PV: Face match (ArcFace >= 0.8)
        PV->>PV: Variation type compliance
        PV->>PV: Intensity compliance (light/medium/far)
        PV->>PV: Quality assessment
    end
    PV->>PV: Cross-miner collusion detection

    Note over PV,DB: Update REPUTATION for NEXT cycle
    PV->>DB: Store post-validation scores
    PV->>DB: Update miner reputation for Cycle N+1
    Note over PV: ‚ö†Ô∏è Does NOT affect current weights!
        </div>

        <!-- Database Schema Diagram -->
        <div id="databaseDiagram" class="mermaid" style="display: none;">
erDiagram
    IDENTITY ||--o{ SEED_IMAGES : "has"
    SEED_IMAGES ||--o{ IMAGE_VARIATIONS : "generates"
    MINER ||--o{ IMAGE_VARIATIONS : "creates"
    IMAGE_VARIATIONS ||--|| IMAGE_VALIDATION : "has"
    IMAGE_VARIATIONS ||--o{ IMAGE_OBSERVATIONS : "tracked_in"
    VALIDATOR ||--o{ IMAGE_OBSERVATIONS : "observes"
    QUERY ||--o{ IMAGE_OBSERVATIONS : "belongs_to"

    IDENTITY {
        BIGINT id PK
        BIGINT seed_name_id FK
        BIGINT seed_address_id FK
        BIGINT seed_dob_id FK
        TEXT label
        DATETIME created_at
    }

    SEED_IMAGES {
        BIGINT id PK
        BIGINT identity_id FK
        TEXT image_hash UK
        TEXT image_data
        INT resolution_width
        INT resolution_height
        TEXT source
        VECTOR face_embedding
        DATETIME created_at
    }

    IMAGE_VARIATIONS {
        BIGINT id PK
        BIGINT seed_image_id FK
        BIGINT miner_id FK
        TEXT variation_type
        TEXT image_data
        TEXT image_hash
        VECTOR face_embedding
        FLOAT face_similarity
        TEXT description
        DATETIME created_at
    }

    IMAGE_VALIDATION {
        BIGINT id PK
        BIGINT variation_id FK
        BOOLEAN face_match_passed
        FLOAT face_similarity_score
        FLOAT prompt_adherence_score
        FLOAT quality_score
        BOOLEAN watermark_detected
        BOOLEAN is_duplicate
        BOOLEAN is_collusion
        TEXT validation_status
        DATETIME validated_at
        DATETIME created_at
    }

    IMAGE_OBSERVATIONS {
        BIGINT id PK
        BIGINT seed_image_id FK
        BIGINT variation_id FK
        BIGINT miner_id FK
        BIGINT validator_id FK
        BIGINT query_id FK
        DATETIME observed_at
    }

    MINER {
        BIGINT id PK
        TEXT hotkey
        TEXT coldkey
        TEXT display_name
        DATETIME created_at
    }

    VALIDATOR {
        BIGINT id PK
        TEXT hotkey
        DATETIME created_at
    }

    QUERY {
        BIGINT id PK
        TEXT query_text
        TEXT query_hash
        DATETIME created_at
    }
        </div>

        <!-- S3 Storage Diagram -->
        <div id="s3Diagram" class="mermaid" style="display: none;">
sequenceDiagram
    autonumber
    participant V as Validator
    participant M as Miner
    participant S3 as S3 (yanez-miid-sn54)
    participant D as Drand Network
    participant PV as YANEZ Post-Validator

    Note over V: Phase 1: Request
    V->>M: Send IdentitySynapse<br/>(base_image, variation_requests[], challenge_id)

    Note over M: Phase 2: Generate & Encrypt
    M->>M: Generate 2-4 image variations
    M->>M: Derive path_signature = sign(challenge_id:hotkey)[:16]
    M->>M: Sign each image with wallet.hotkey
    M->>D: Get future drand round (72 min)
    D-->>M: Round number + public key
    M->>M: Timelock encrypt images<br/>(tlock.encrypt)

    Note over M,S3: Phase 3: Upload to S3 (path protected)
    M->>S3: PUT /{challenge_id}/{hotkey}/{path_signature}/*.tlock
    Note right of S3: Metadata:<br/>- miner_hotkey<br/>- signature<br/>- path_signature<br/>- image_hash<br/>- drand_round
    S3-->>M: Upload confirmation

    M->>V: Return S3Submissions[]<br/>(s3_key, hash, signature, path_signature)

    Note over V,D: Phase 4: Wait for Reveal (~72 min)
    V->>V: Store refs for YANEZ
    D->>D: Drand beacon published after 1 epoch

    Note over PV,S3: Phase 5: YANEZ Post-Validation
    PV->>S3: Fetch encrypted images
    S3-->>PV: Encrypted data + metadata
    PV->>PV: Verify path_signature matches path
    PV->>PV: Decrypt with drand beacon
    PV->>PV: verify_message(signature, hotkey)
    alt Valid
        PV->>PV: Face matching (ArcFace)
        PV->>PV: Type + intensity compliance
    else Invalid
        PV->>PV: Reject submission
    end
        </div>

        <!-- Drand Timelock Diagram -->
        <div id="drandDiagram" class="mermaid" style="display: none;">
flowchart LR
    subgraph Timeline["Drand Timelock Timeline (72 min = 1 Bittensor Epoch)"]
        T0["t0: Request Sent"]
        T1["t1: Miner Encrypts<br/>(future round N)"]
        T2["t2: All Commits<br/>Uploaded to S3"]
        T3["t3: ~72 min later<br/>Drand Round N<br/>Beacon Published"]
        T4["t4: Simultaneous<br/>Reveal by YANEZ"]
    end

    subgraph Encryption["Timelock Encryption"]
        E1["Miner gets future<br/>drand round number<br/>(~1440 rounds ahead)"]
        E2["Encrypt with tlock:<br/>tlock.encrypt(<br/>  data,<br/>  round_number,<br/>  drand_public_key<br/>)"]
        E3["Cannot decrypt until<br/>drand publishes beacon<br/>(72 min = 4320 sec)"]
    end

    subgraph Storage["Commit Phase"]
        ST1["Miner signs data<br/>with wallet.hotkey"]
        ST2["Upload to S3 with:<br/>- encrypted_data<br/>- miner_hotkey<br/>- signature<br/>- path_signature<br/>- target_round"]
        ST3["All miners commit<br/>before reveal time"]
    end

    subgraph Reveal["Reveal Phase (YANEZ Post-Validator)"]
        R1["Drand beacon published<br/>at round N (~72 min)"]
        R2["YANEZ fetches<br/>from S3"]
        R3["Decrypt with beacon:<br/>tlock.decrypt(<br/>  encrypted_data,<br/>  beacon_signature<br/>)"]
        R4["Verify miner identity:<br/>verify_message(<br/>  signature,<br/>  hotkey<br/>)"]
    end

    subgraph Benefits["Why Timelock?"]
        B1["No Early Peeking:<br/>Validators can't see<br/>submissions early"]
        B2["Fair Competition:<br/>All reveals happen<br/>simultaneously"]
        B3["Anti-Gaming:<br/>Miners can't adjust<br/>based on others"]
        B4["Verifiable:<br/>Drand is decentralized<br/>and trustless"]
    end

    T0 --> T1
    T1 --> T2
    T2 --> T3
    T3 --> T4

    E1 --> E2
    E2 --> E3

    ST1 --> ST2
    ST2 --> ST3

    R1 --> R2
    R2 --> R3
    R3 --> R4

    style T0 fill:#e0e7ff,stroke:#6366f1
    style T1 fill:#e0e7ff,stroke:#6366f1
    style T2 fill:#e0e7ff,stroke:#6366f1
    style T3 fill:#e0e7ff,stroke:#6366f1
    style T4 fill:#e0e7ff,stroke:#6366f1
    style E1 fill:#fef3c7,stroke:#f59e0b
    style E2 fill:#fef3c7,stroke:#f59e0b
    style E3 fill:#fef3c7,stroke:#f59e0b
    style ST1 fill:#d1fae5,stroke:#10b981
    style ST2 fill:#d1fae5,stroke:#10b981
    style ST3 fill:#d1fae5,stroke:#10b981
    style R1 fill:#dbeafe,stroke:#3b82f6
    style R2 fill:#dbeafe,stroke:#3b82f6
    style R3 fill:#dbeafe,stroke:#3b82f6
    style R4 fill:#dbeafe,stroke:#3b82f6
    style B1 fill:#fce7f3,stroke:#ec4899
    style B2 fill:#fce7f3,stroke:#ec4899
    style B3 fill:#fce7f3,stroke:#ec4899
    style B4 fill:#fce7f3,stroke:#ec4899
        </div>

        <!-- Description Section -->
        <div id="overviewDesc" class="description">
            <h3>Phase 4 Overview</h3>
            <p>Phase 4 extends MIID Subnet with synthetic image variations for KYC verification.</p>
            <ul>
                <li><strong>Online (Immediate):</strong> Validator sends base image + 2-4 variation requests (type √ó intensity) ‚Üí Miner uploads encrypted variations to S3 (<code>yanez-miid-sn54</code>) ‚Üí Validator sets weights using KAV + previous reputation</li>
                <li><strong>Post-Validation (After ~72 min = 1 Bittensor epoch):</strong> YANEZ decrypts images ‚Üí Face matching, type/intensity compliance, quality, cheat detection ‚Üí Update reputation for NEXT cycle</li>
            </ul>
            <p><strong>Key Security Features:</strong> <code>path_signature</code> prevents miners from overwriting others' submissions; drand timelock ensures fair reveal.</p>
        </div>

        <div id="sandboxDesc" class="description" style="display: none;">
            <h3>Sandbox Testing Flow (Phase4-C1-Sandbox)</h3>
            <p>Sandbox environment for testing Phase 4 logic before production deployment. Cycle label: <code>Phase4-C1-Sandbox</code></p>
            <ul>
                <li><strong>Validator:</strong> Loads base images from local <code>./base_images/</code> folder, dynamically selects 2-4 variation types with intensities</li>
                <li><strong>Miner:</strong> Uses placeholder <code>generate_variations()</code> that returns copies (model to be integrated later)</li>
                <li><strong>Encryption:</strong> Real drand timelock encryption with <code>tlock.encrypt()</code> (72 min reveal = 1 Bittensor epoch)</li>
                <li><strong>S3 Upload:</strong> Real S3 bucket: <code>s3://yanez-miid-sn54/</code></li>
                <li><strong>Security:</strong> <code>path_signature</code> prevents miners from overwriting others' submissions</li>
                <li><strong>Full Flow:</strong> Complete end-to-end testing of synapse, signing, encryption, and response handling</li>
            </ul>
            <table class="spec-table">
                <tr><th>Component</th><th>Status</th><th>Notes</th></tr>
                <tr><td>Base Image Source</td><td>üìÅ Local Folder</td><td><code>./base_images/*.jpg</code></td></tr>
                <tr><td>Variation Selection</td><td>‚úÖ Dynamic</td><td>2-4 types √ó light/medium/far</td></tr>
                <tr><td>Image Generator</td><td>üîß Placeholder</td><td>Returns copies, model TBD</td></tr>
                <tr><td>Drand Encryption</td><td>‚úÖ Real</td><td><code>tlock.encrypt()</code> (72 min)</td></tr>
                <tr><td>S3 Upload</td><td>‚úÖ Real</td><td><code>yanez-miid-sn54</code></td></tr>
                <tr><td>Path Security</td><td>‚úÖ Real</td><td><code>path_signature</code></td></tr>
                <tr><td>Wallet Signing</td><td>‚úÖ Real</td><td><code>wallet.hotkey.sign()</code></td></tr>
                <tr><td>YANEZ Upload</td><td>‚úÖ Real</td><td>Existing code path</td></tr>
            </table>
        </div>

        <div id="detailedDesc" class="description" style="display: none;">
            <h3>Detailed Data Flow (Two-Stage)</h3>
            <ul>
                <li><strong>Input:</strong> Validator selects base image, dynamically picks 2-4 variation types with intensities (light/medium/far)</li>
                <li><strong>Synapse Request:</strong> base_image, variation_requests[] (type + intensity), target_drand_round, challenge_id (includes validator hotkey)</li>
                <li><strong>Miner Processing:</strong> Generate variations ‚Üí Derive path_signature ‚Üí Sign ‚Üí Encrypt with drand (72 min reveal) ‚Üí Upload to S3</li>
                <li><strong>Synapse Response:</strong> S3 paths, hashes, signatures, path_signature (NOT images)</li>
                <li><strong>ONLINE (Immediate):</strong> KAV validation + previous reputation ‚Üí <strong>SET WEIGHTS NOW</strong> ‚Üí Store S3 refs for YANEZ</li>
                <li><strong>POST-VALIDATION (After ~72 min):</strong> YANEZ downloads ‚Üí Decrypts ‚Üí Face match ‚Üí Type/intensity compliance ‚Üí <strong>Update reputation for NEXT cycle</strong></li>
            </ul>
        </div>

        <div id="protocolDesc" class="description" style="display: none;">
            <h3>Protocol Extension</h3>
            <p>The existing <code>IdentitySynapse</code> is extended with three new types:</p>
            <ul>
                <li><strong>VariationRequest:</strong> Defines each variation with <code>type</code> (pose_edit, lighting_edit, expression_edit, background_edit) and <code>intensity</code> (light/medium/far)</li>
                <li><strong>ImageRequest:</strong> Sent by validator with base image, <code>variation_requests[]</code>, <code>challenge_id</code> (includes validator hotkey for uniqueness), and <code>target_drand_round</code></li>
                <li><strong>S3Submission:</strong> Returned by miner with <code>s3_key</code>, <code>image_hash</code>, <code>signature</code>, <code>variation_type</code>, and <code>path_signature</code> (prevents path hijacking)</li>
            </ul>
            <p><strong>Key changes:</strong></p>
            <ul>
                <li>Miners return S3 references, NOT actual images. Images are encrypted and stored in S3 until drand reveal (~72 min).</li>
                <li><code>path_signature = sign(challenge_id:hotkey)[:16]</code> prevents malicious miners from writing to others' paths.</li>
            </ul>
        </div>

        <div id="validationDesc" class="description" style="display: none;">
            <h3>Two-Stage Validation Pipeline</h3>
            <ul>
                <li><strong>STAGE 1: Online Validation (Immediate)</strong>
                    <ul>
                        <li>Validator receives S3 references from miners (s3_key, hash, signature, path_signature)</li>
                        <li>Validates KAV (Name/DOB/Address) immediately</li>
                        <li>Applies <strong>previous cycle's reputation</strong></li>
                        <li><strong>SETS WEIGHTS ON-CHAIN NOW</strong></li>
                        <li>Stores S3 refs + variation_requests for YANEZ post-validation</li>
                    </ul>
                </li>
                <li><strong>STAGE 2: Post-Validation (After ~72 min = 1 Bittensor Epoch)</strong>
                    <ul>
                        <li>YANEZ downloads encrypted images from S3 (<code>yanez-miid-sn54</code>)</li>
                        <li>Verifies path_signature matches S3 path</li>
                        <li>Decrypt with drand beacon</li>
                        <li>ALL image validation: face matching, type/intensity compliance, quality, cheat detection</li>
                        <li><strong>Updates REPUTATION for NEXT cycle</strong></li>
                        <li>‚ö†Ô∏è Does NOT affect current weights!</li>
                    </ul>
                </li>
            </ul>
        </div>

        <div id="databaseDesc" class="description" style="display: none;">
            <h3>Database Schema</h3>
            <p>Phase 4 adds four new tables to the existing MIID database:</p>
            <ul>
                <li><strong>seed_images:</strong> Base images from database (FLUXSynID placeholder for future)</li>
                <li><strong>image_variations:</strong> Miner-generated variations with embeddings and similarity scores</li>
                <li><strong>image_validation:</strong> Validation results including face match, quality, and cheat flags</li>
                <li><strong>image_observations:</strong> Links variations to miners, validators, and queries</li>
            </ul>
        </div>

        <div id="s3Desc" class="description" style="display: none;">
            <h3>S3 Storage & Wallet Verification</h3>
            <p>Miners upload encrypted image variations to S3 (<code>s3://yanez-miid-sn54/</code>) with wallet-based authentication and path security.</p>
            <table class="spec-table">
                <tr><th>Step</th><th>Action</th><th>Purpose</th></tr>
                <tr><td>1. Path Signature</td><td><code>sign(challenge_id:hotkey)[:16]</code></td><td>Prevent path hijacking</td></tr>
                <tr><td>2. Sign Image</td><td><code>wallet.hotkey.sign(data)</code></td><td>Prove miner identity</td></tr>
                <tr><td>3. Encrypt</td><td><code>tlock.encrypt(data, round)</code></td><td>Timelock until reveal (72 min)</td></tr>
                <tr><td>4. Upload</td><td>S3 path: <code>/{challenge_id}/{hotkey}/{path_signature}/</code></td><td>Commit submission</td></tr>
                <tr><td>5. Verify</td><td><code>verify_message(signature, hotkey)</code></td><td>Confirm miner identity</td></tr>
            </table>
            <p><strong>S3 Path Structure:</strong> <code>submissions/{challenge_id}/{miner_hotkey}/{path_signature}/{variation_type}_{timestamp}.png.tlock</code></p>
            <p><strong>Key Files:</strong> <code>MIID/miner/s3_upload.py</code>, <code>MIID/utils/sign_message.py</code>, <code>MIID/utils/verify_message.py</code></p>
        </div>

        <div id="drandDesc" class="description" style="display: none;">
            <h3>Drand Timelock Encryption</h3>
            <p>Drand is a distributed randomness beacon that enables time-locked encryption. Data encrypted for a future round can only be decrypted after that round's beacon is published.</p>
            <table class="spec-table">
                <tr><th>Parameter</th><th>Value</th></tr>
                <tr><td>Network</td><td>Drand Quicknet</td></tr>
                <tr><td>Round Period</td><td>3 seconds</td></tr>
                <tr><td>Reveal Buffer</td><td><strong>72 minutes (4320 seconds = 1 Bittensor epoch)</strong></td></tr>
                <tr><td>Rounds Ahead</td><td>~1440 rounds (4320 sec √∑ 3 sec/round)</td></tr>
                <tr><td>URL</td><td><code>https://api.drand.sh/52db9ba70e0cc0f6eaf7803dd07447a1f5477735fd3f661792ba94600c84e971</code></td></tr>
            </table>
            <h4>Benefits</h4>
            <ul>
                <li><strong>Fair Competition:</strong> All submissions revealed simultaneously after 1 Bittensor epoch</li>
                <li><strong>Anti-Gaming:</strong> Miners cannot adjust based on seeing other submissions</li>
                <li><strong>Trustless:</strong> Drand is decentralized - no single point of failure</li>
                <li><strong>Verifiable:</strong> Anyone can verify the beacon was used correctly</li>
                <li><strong>Aligned with Bittensor:</strong> 72-minute reveal aligns with Bittensor epoch timing</li>
            </ul>
        </div>

    </div>

    <script>
        mermaid.initialize({
            startOnLoad: false,
            securityLevel: 'loose',
            theme: 'default',
            flowchart: {
                useMaxWidth: true,
                htmlLabels: true,
                curve: 'basis',
                diagramPadding: 16,
                nodeSpacing: 80,
                rankSpacing: 150
            }
        });

        async function renderMermaid(id) {
            const el = document.getElementById(id);
            if (!el) return;
            if (el.getAttribute('data-rendered')) return;
            try {
                const code = el.textContent.trim();
                const { svg } = await mermaid.render(id + "__svg", code);
                el.innerHTML = svg;
                el.setAttribute('data-rendered', 'true');
            } catch (e) {
                console.error('Mermaid render error for', id, e);
                el.innerText = 'Mermaid render error: ' + (e && e.message ? e.message : e);
            }
        }

        renderMermaid('overviewDiagram');

        const diagrams = ['overviewDiagram', 'sandboxDiagram', 'detailedDiagram', 'protocolDiagram', 'validationDiagram', 'databaseDiagram', 's3Diagram', 'drandDiagram'];
        const descriptions = ['overviewDesc', 'sandboxDesc', 'detailedDesc', 'protocolDesc', 'validationDesc', 'databaseDesc', 's3Desc', 'drandDesc'];
        const buttons = ['overviewBtn', 'sandboxBtn', 'detailedBtn', 'protocolBtn', 'validationBtn', 'databaseBtn', 's3Btn', 'drandBtn'];

        function hideAll() {
            diagrams.forEach(d => document.getElementById(d).style.display = 'none');
            descriptions.forEach(d => document.getElementById(d).style.display = 'none');
            buttons.forEach(b => document.getElementById(b).classList.remove('active'));
        }

        async function showDiagram(index) {
            hideAll();
            await renderMermaid(diagrams[index]);
            document.getElementById(diagrams[index]).style.display = 'block';
            document.getElementById(descriptions[index]).style.display = 'block';
            document.getElementById(buttons[index]).classList.add('active');
        }

        async function showOverview() { await showDiagram(0); }
        async function showSandbox() { await showDiagram(1); }
        async function showDetailed() { await showDiagram(2); }
        async function showProtocol() { await showDiagram(3); }
        async function showValidation() { await showDiagram(4); }
        async function showDatabase() { await showDiagram(5); }
        async function showS3() { await showDiagram(6); }
        async function showDrand() { await showDiagram(7); }
    </script>
</body>
</html>
