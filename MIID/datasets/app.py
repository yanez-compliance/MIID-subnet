import os
import base64
import json
import secrets
import time
import threading
from pathlib import Path
from flask import Flask, request, jsonify
from datetime import datetime

# Import configuration
from MIID.datasets.config import (
    HOST,
    PORT,
    DEBUG,
    DATA_DIR,
    ALLOWED_HOTKEYS,
    REPUTATION_SNAPSHOT_PATH,
    REWARDS_DIR,
)

# Import methods from db_machine
import sys
sys.path.insert(0, '/home/ubuntu/YanezMIIDManage')
from db_machine import get_snapshot, reward_allocation

# Use fake calls for testing (reads from JSON file instead of database)
# from MIID.datasets.fake_calls import get_snapshot, reward_allocation


# Import verify_message function
from MIID.utils.verify_message import verify_message

## gunicorn MIID.datasets.app:app --bind 0.0.0.0:5000 --workers 4

# =============================================================================
# Validator base images (hotkey -> folder under base_images)
# =============================================================================
BASE_IMAGES_DIR = Path("/home/ubuntu/YanezMIIDManage/api_image/base_images")
HOTKEY_TO_FOLDER = {
    "5DUB7kNLvvx8Dj7D8tn54N1C7Xok6GodNPQE2WECCaL9Wgpr": "miid",
    "5GWzXSra6cBM337nuUU7YTjZQ6ewT2VakDpMj8Pw2i8v8PVs": "yuma",
    "5C4qiYkqKjqGDSvzpf6YXCcnBgM6punh8BQJRP78bqMGsn54": "rt21",
    "5HK5tp6t2S59DywmHRWPBVJeJ86T61KjurYqeooqj8sREpeN": "tensora",
    "5HbUFHW4XVhbQvMbSy7WDjvhHb62nuYgP1XBsmmz9E2E2K6p": "otf",
    "5GQqAhLKVHRLpdTqRg1yc3xu7y47DicJykSpggE2GuDbfs54": "rizzo",
    "5CnkkjPdfsA6jJDHv2U6QuiKiivDuvQpECC13ffdmSDbkgtt": "testnet",
}


# =============================================================================
# Reputation Snapshot Cache (Phase 4 - Cycle 1)
# =============================================================================

# Global reputation snapshot cache (thread-safe)
CURRENT_REP_SNAPSHOT = {
    "version": None,
    "generated_at": None,
    "miners": {}
}
_snapshot_lock = threading.Lock()


def load_reputation_snapshot():
    """
    Load reputation snapshot from JSON file into memory.

    Called at Flask startup and can be called to reload the snapshot.
    Thread-safe using _snapshot_lock.
    """
    global CURRENT_REP_SNAPSHOT

    if not os.path.exists(REPUTATION_SNAPSHOT_PATH):
        print(f"[WARNING] Reputation snapshot not found at {REPUTATION_SNAPSHOT_PATH}. Using empty snapshot.")
        return

    try:
        with open(REPUTATION_SNAPSHOT_PATH, 'r', encoding='utf-8') as f:
            data = json.load(f)

        with _snapshot_lock:
            CURRENT_REP_SNAPSHOT = {
                "version": data.get("version"),
                "generated_at": data.get("generated_at"),
                "miners": data.get("miners", {})
            }
        print(f"[INFO] Loaded reputation snapshot version: {CURRENT_REP_SNAPSHOT['version']} with {len(CURRENT_REP_SNAPSHOT['miners'])} miners")
    except Exception as e:
        print(f"[ERROR] Failed to load reputation snapshot: {e}")


# Load snapshot on module import (Flask startup)
load_reputation_snapshot()

# =============================================================================

app = Flask(__name__)

# Ensure the data directory exists
os.makedirs(DATA_DIR, exist_ok=True)

@app.route('/upload_data/<hotkey>', methods=['POST'])
def upload_data(hotkey):
    # Check if the hotkey is allowed
    if hotkey not in ALLOWED_HOTKEYS:
        return jsonify({"error": "Unauthorized hotkey"}), 403

    # 2) Check that the incoming request body is JSON
    if not request.is_json:
        return jsonify({"error": "Request body must be JSON"}), 400
    
    # 3) Get the JSON payload
    data = request.get_json()

    # 4) The "signature" field in the payload must contain the lines
    #    generated by sign_message (the <Bytes>... block, plus
    #    "Signed by:" and "Signature:" lines).
    signature_text = data.get("signature")
    if not signature_text:
        return jsonify({"error": "Missing 'signature' in JSON payload"}), 400

    # 5) Create a temporary file to hold just the signature text.
    #    verify_message() expects to read this file and parse it.
    tmp_signature_filename = os.path.join(DATA_DIR, f"tmp_signature_{time.time()}.txt")
    with open(tmp_signature_filename, 'w', encoding='utf-8') as tmp_file:
        tmp_file.write(signature_text)

    # 6) Attempt to verify the signature. If it fails, remove the temporary file and reject.
    try:
        verify_message(tmp_signature_filename)
        # If no ValueError was raised, the signature is valid.
    except ValueError as e:
        os.remove(tmp_signature_filename)
        return jsonify({"error": f"Signature verification failed: {str(e)}"}), 400

    # 7) Verification succeeded, remove the temporary file (optional to keep or discard).
    os.remove(tmp_signature_filename)

    # 8) Create a folder for this hotkey if it doesn't exist
    hotkey_folder = os.path.join(DATA_DIR, hotkey)
    os.makedirs(hotkey_folder, exist_ok=True)
    
    # 9) Create a unique filename for storing the full JSON data:
    timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
    random_hex = secrets.token_hex(4)
    final_filename = f"{hotkey}.{timestamp}.{random_hex}.json"
    filepath = os.path.join(hotkey_folder, final_filename)

    # 10) Save the entire JSON data (including the signature) to disk.
    with open(filepath, 'w', encoding='utf-8') as f:
        json.dump(data, f, indent=2)

    # ==========================================================================
    # 11) Get current snapshot from database (used for both reward processing and response)
    # Thread-safe: Lock to prevent race conditions when multiple requests process rewards
    # ==========================================================================
    snapshot_version = None
    generated_at = None
    rep_cache = {}
    current_snapshot = None
    
    with _snapshot_lock:
        try:
            current_snapshot = get_snapshot()
            
            snapshot_version = current_snapshot.get("version")
            generated_at = current_snapshot.get("generated_at")
            
            # Convert miners list to dict keyed by hotkey for rep_cache response
            # The JSON has miners as a list: [{hotkey, rep_score, rep_tier, ...}, ...]
            miners_list = current_snapshot.get("miners", [])
            for miner in miners_list:
                hotkey_key = miner.get("hotkey")
                if hotkey_key:
                    rep_cache[hotkey_key] = {
                        "rep_score": miner.get("rep_score", 0),
                        "rep_tier": miner.get("rep_tier", "Unknown")
                    }
            
            print(f"[INFO] Retrieved snapshot from get_snapshot(): version={snapshot_version}, miners={len(rep_cache)}")

        except Exception as e:
            print(f"[ERROR] Failed to get snapshot from get_snapshot(): {e}")

        # ==========================================================================
        # 12) Process reward_allocation if present (Phase 4 - Cycle 1)
        # Update miners with rewards and send to database
        # ==========================================================================
        reward_allocation_data = data.get("reward_allocation")
        if reward_allocation_data and current_snapshot:
            try:
                # Handle allocations array (may contain multiple pending allocations)
                allocations = reward_allocation_data.get("allocations", [])

                # If no allocations array, check for legacy "miners" field (backwards compatibility)
                if not allocations and reward_allocation_data.get("miners"):
                    allocations = [{
                        "timestamp": reward_allocation_data.get("rep_snapshot_version"),
                        "rep_snapshot_version": reward_allocation_data.get("rep_snapshot_version"),
                        "miners": reward_allocation_data.get("miners")
                    }]

                # Collect all miners that received rewards (from all allocations) with their reward data
                rewarded_miners_data = {}  # {miner_hotkey: {uav_contribution, kav_contribution, final_reward}, ...}
                for allocation in allocations:
                    allocation_miners = allocation.get("miners", [])
                    for allocation_miner in allocation_miners:
                        # Reward allocation uses "miner_hotkey" field, not "hotkey"
                        miner_hotkey = allocation_miner.get("miner_hotkey")
                        if miner_hotkey:
                            # Store reward data for this miner
                            uav_contribution = allocation_miner.get("uav_contribution", 0.0)
                            kav_contribution = allocation_miner.get("kav_contribution", 0.0)
                            final_reward = allocation_miner.get("final_reward", 0.0)
                            rewarded_miners_data[miner_hotkey] = {
                                "uav_contribution": uav_contribution,
                                "kav_contribution": kav_contribution,
                                "final_reward": final_reward
                            }
                
                # Create a dict of current snapshot miners keyed by hotkey for easy lookup
                snapshot_miners_list = current_snapshot.get("miners", [])
                snapshot_miners_dict = {miner.get("hotkey"): miner for miner in snapshot_miners_list}
                
                # For each miner that received rewards and exists in database, subtract 0.01 from rep_score
                # Only apply penalty if miner actually got rewards (uav_contribution > 0)
                updated_miners_count = 0
                for miner_hotkey, reward_data in rewarded_miners_data.items():
                    if miner_hotkey in snapshot_miners_dict:
                        # Check if miner actually received rewards
                        uav_contribution = reward_data.get("uav_contribution", 0.0)
                        
                        # Only apply penalty if miner got rewards (uav_contribution > 0)
                        if uav_contribution > 0.0:
                            snapshot_miner = snapshot_miners_dict[miner_hotkey]
                            current_score = snapshot_miner.get("rep_score", 0.0)
                            # Subtract 0.01 from rep_score
                            snapshot_miner["rep_score"] = max(0.0, current_score - 0.01)
                            # Also update rep_cache to reflect the change
                            if miner_hotkey in rep_cache:
                                rep_cache[miner_hotkey]["rep_score"] = snapshot_miner["rep_score"]
                            updated_miners_count += 1

                # Send updated snapshot to database using reward_allocation
                if updated_miners_count > 0:
                    result = reward_allocation(current_snapshot)
                    print(f"[INFO] Applied decay (-0.01) to {updated_miners_count} miner(s) and sent to database via reward_allocation()")
                else:
                    print(f"[INFO] No miners to update in reward allocation")

            except Exception as e:
                print(f"[ERROR] Failed to process reward_allocation: {e}")

    # 13) Return a success response with rep_cache
    return jsonify({
        "message": "Data received and verified successfully",
        "filename": final_filename,
        # Reputation cache for next forward pass (Phase 4 - Cycle 1)
        "rep_snapshot_version": snapshot_version,
        "generated_at": generated_at,
        "rep_cache": rep_cache  # All miners: {hotkey: {rep_score, rep_tier}, ...}
    }), 200


@app.route('/images/<hotkey>', methods=['POST'])
def get_validator_images(hotkey):
    """
    Return all base images for this validator (that hotkey's folder under base_images).
    Request body: JSON with "signature" (signed message from that hotkey).
    Response: { "validator_folder", "verified_by", "images": [{ "filename", "data_base64" }, ...], "count" }.
    """
    if hotkey not in ALLOWED_HOTKEYS:
        return jsonify({"error": "Unauthorized hotkey"}), 403

    if not request.is_json:
        return jsonify({"error": "Request body must be JSON"}), 400

    data = request.get_json()
    signature_text = data.get("signature")
    if not signature_text:
        return jsonify({"error": "Missing 'signature' in JSON payload"}), 400

    tmp_signature_filename = os.path.join(DATA_DIR, f"tmp_signature_images_{time.time()}.txt")
    with open(tmp_signature_filename, 'w', encoding='utf-8') as tmp_file:
        tmp_file.write(signature_text)

    try:
        verify_message(tmp_signature_filename)
    except ValueError as e:
        os.remove(tmp_signature_filename)
        return jsonify({"error": f"Signature verification failed: {str(e)}"}), 400

    os.remove(tmp_signature_filename)

    folder_name = HOTKEY_TO_FOLDER.get(hotkey)
    if not folder_name:
        return jsonify({"error": "No image folder configured for this validator"}), 404

    images_dir = BASE_IMAGES_DIR / folder_name
    if not images_dir.is_dir():
        return jsonify({"error": f"Image folder not found: {folder_name}"}), 404

    images = []
    allowed_ext = ('.png', '.jpg', '.jpeg', '.gif', '.webp')
    for f in sorted(images_dir.iterdir()):
        if f.is_file() and f.suffix.lower() in allowed_ext:
            try:
                b64 = base64.standard_b64encode(f.read_bytes()).decode('ascii')
                images.append({"filename": f.name, "data_base64": b64})
            except Exception:
                pass

    return jsonify({
        "validator_folder": folder_name,
        "verified_by": hotkey,
        "images": images,
        "count": len(images),
    }), 200


if __name__ == '__main__':
    app.run(host=HOST, port=PORT, debug=DEBUG)
