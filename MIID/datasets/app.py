import os
import json
import secrets
import time
import threading
from flask import Flask, request, jsonify
from datetime import datetime

# Import configuration
from MIID.datasets.config import (
    HOST,
    PORT,
    DEBUG,
    DATA_DIR,
    ALLOWED_HOTKEYS,
    REPUTATION_SNAPSHOT_PATH,
    REWARDS_DIR,
)

# Import verify_message function
from MIID.utils.verify_message import verify_message

## gunicorn MIID.datasets.app:app --bind 0.0.0.0:5000 --workers 4

# =============================================================================
# Reputation Snapshot Cache (Phase 3 - Cycle 2)
# =============================================================================

# Global reputation snapshot cache (thread-safe)
CURRENT_REP_SNAPSHOT = {
    "version": None,
    "generated_at": None,
    "miners": {}
}
_snapshot_lock = threading.Lock()


def load_reputation_snapshot():
    """
    Load reputation snapshot from JSON file into memory.

    Called at Flask startup and can be called to reload the snapshot.
    Thread-safe using _snapshot_lock.
    """
    global CURRENT_REP_SNAPSHOT

    if not os.path.exists(REPUTATION_SNAPSHOT_PATH):
        print(f"[WARNING] Reputation snapshot not found at {REPUTATION_SNAPSHOT_PATH}. Using empty snapshot.")
        return

    try:
        with open(REPUTATION_SNAPSHOT_PATH, 'r', encoding='utf-8') as f:
            data = json.load(f)

        with _snapshot_lock:
            CURRENT_REP_SNAPSHOT = {
                "version": data.get("version"),
                "generated_at": data.get("generated_at"),
                "miners": data.get("miners", {})
            }
        print(f"[INFO] Loaded reputation snapshot version: {CURRENT_REP_SNAPSHOT['version']} with {len(CURRENT_REP_SNAPSHOT['miners'])} miners")
    except Exception as e:
        print(f"[ERROR] Failed to load reputation snapshot: {e}")


# Load snapshot on module import (Flask startup)
load_reputation_snapshot()

# =============================================================================

app = Flask(__name__)

# Ensure the data directory exists
os.makedirs(DATA_DIR, exist_ok=True)

@app.route('/upload_data/<hotkey>', methods=['POST'])
def upload_data(hotkey):
    # Check if the hotkey is allowed
    if hotkey not in ALLOWED_HOTKEYS:
        return jsonify({"error": "Unauthorized hotkey"}), 403

    # 2) Check that the incoming request body is JSON
    if not request.is_json:
        return jsonify({"error": "Request body must be JSON"}), 400
    
    # 3) Get the JSON payload
    data = request.get_json()

    # 4) The "signature" field in the payload must contain the lines
    #    generated by sign_message (the <Bytes>... block, plus
    #    "Signed by:" and "Signature:" lines).
    signature_text = data.get("signature")
    if not signature_text:
        return jsonify({"error": "Missing 'signature' in JSON payload"}), 400

    # 5) Create a temporary file to hold just the signature text.
    #    verify_message() expects to read this file and parse it.
    tmp_signature_filename = os.path.join(DATA_DIR, f"tmp_signature_{time.time()}.txt")
    with open(tmp_signature_filename, 'w', encoding='utf-8') as tmp_file:
        tmp_file.write(signature_text)

    # 6) Attempt to verify the signature. If it fails, remove the temporary file and reject.
    try:
        verify_message(tmp_signature_filename)
        # If no ValueError was raised, the signature is valid.
    except ValueError as e:
        os.remove(tmp_signature_filename)
        return jsonify({"error": f"Signature verification failed: {str(e)}"}), 400

    # 7) Verification succeeded, remove the temporary file (optional to keep or discard).
    os.remove(tmp_signature_filename)

    # 8) Create a folder for this hotkey if it doesn't exist
    hotkey_folder = os.path.join(DATA_DIR, hotkey)
    os.makedirs(hotkey_folder, exist_ok=True)
    
    # 9) Create a unique filename for storing the full JSON data:
    timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
    random_hex = secrets.token_hex(4)
    final_filename = f"{hotkey}.{timestamp}.{random_hex}.json"
    filepath = os.path.join(hotkey_folder, final_filename)

    # 10) Save the entire JSON data (including the signature) to disk.
    with open(filepath, 'w', encoding='utf-8') as f:
        json.dump(data, f, indent=2)

    # ==========================================================================
    # 11) Extract and save reward_allocation if present (Phase 3 - Cycle 2)
    # ==========================================================================
    reward_allocation = data.get("reward_allocation")
    if reward_allocation:
        cycle_id = reward_allocation.get("cycle_id", "unknown")

        # Handle allocations array (may contain multiple pending allocations)
        allocations = reward_allocation.get("allocations", [])

        # If no allocations array, check for legacy "miners" field (backwards compatibility)
        if not allocations and reward_allocation.get("miners"):
            allocations = [{
                "timestamp": reward_allocation.get("rep_snapshot_version"),
                "rep_snapshot_version": reward_allocation.get("rep_snapshot_version"),
                "miners": reward_allocation.get("miners")
            }]

        # Save each allocation separately
        saved_count = 0
        for allocation in allocations:
            # Save to REWARDS_DIR/<cycle_id>/<hotkey>/
            rewards_dir = os.path.join(REWARDS_DIR, cycle_id, hotkey)
            os.makedirs(rewards_dir, exist_ok=True)

            reward_timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
            reward_hex = secrets.token_hex(4)
            reward_filename = f"reward_{reward_timestamp}.{reward_hex}.json"
            reward_filepath = os.path.join(rewards_dir, reward_filename)

            with open(reward_filepath, 'w', encoding='utf-8') as f:
                json.dump(allocation, f, indent=2)

            saved_count += 1

        print(f"[INFO] Saved {saved_count} reward allocation(s) for validator {hotkey[:16]}...")

    # ==========================================================================
    # 12) Get rep_cache for response (Phase 3 - Cycle 2)
    # ==========================================================================
    with _snapshot_lock:
        snapshot_version = CURRENT_REP_SNAPSHOT.get("version")
        generated_at = CURRENT_REP_SNAPSHOT.get("generated_at")
        rep_cache = CURRENT_REP_SNAPSHOT.get("miners", {})

    # 13) Return a success response with rep_cache
    return jsonify({
        "message": "Data received and verified successfully",
        "filename": final_filename,
        # Reputation cache for next forward pass (Phase 3 - Cycle 2)
        "rep_snapshot_version": snapshot_version,
        "generated_at": generated_at,
        "rep_cache": rep_cache  # All miners: {hotkey: {rep_score, rep_tier}, ...}
    }), 200

if __name__ == '__main__':
    app.run(host=HOST, port=PORT, debug=DEBUG)
