import os
import json
import secrets
import time
from flask import Flask, request, jsonify
from datetime import datetime

# Import configuration
from MIID.datasets.config import (
    HOST,
    PORT,
    DEBUG,
    DATA_DIR,
    ALLOWED_HOTKEYS
)

# Import verify_message function
from MIID.utils.verify_message import verify_message

app = Flask(__name__)

# Ensure the data directory exists
os.makedirs(DATA_DIR, exist_ok=True)

@app.route('/upload_data/<hotkey>', methods=['POST'])
def upload_data(hotkey):
    # Check if the hotkey is allowed
    if hotkey not in ALLOWED_HOTKEYS:
        return jsonify({"error": "Unauthorized hotkey"}), 403

    # 2) Check that the incoming request body is JSON
    if not request.is_json:
        return jsonify({"error": "Request body must be JSON"}), 400
    
    # 3) Get the JSON payload
    data = request.get_json()

    # 4) The "signature" field in the payload must contain the lines
    #    generated by sign_message (the <Bytes>... block, plus
    #    "Signed by:" and "Signature:" lines).
    signature_text = data.get("signature")
    if not signature_text:
        return jsonify({"error": "Missing 'signature' in JSON payload"}), 400

    # 5) Create a temporary file to hold just the signature text.
    #    verify_message() expects to read this file and parse it.
    tmp_signature_filename = os.path.join(DATA_DIR, f"tmp_signature_{time.time()}.txt")
    with open(tmp_signature_filename, 'w', encoding='utf-8') as tmp_file:
        tmp_file.write(signature_text)

    # 6) Attempt to verify the signature. If it fails, remove the temporary file and reject.
    try:
        verify_message(tmp_signature_filename)
        # If no ValueError was raised, the signature is valid.
    except ValueError as e:
        os.remove(tmp_signature_filename)
        return jsonify({"error": f"Signature verification failed: {str(e)}"}), 400

    # 7) Verification succeeded, remove the temporary file (optional to keep or discard).
    os.remove(tmp_signature_filename)

    # 8) Create a unique filename for storing the full JSON data:
    timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
    random_hex = secrets.token_hex(4)
    final_filename = f"{hotkey}.{timestamp}.{random_hex}.json"
    filepath = os.path.join(DATA_DIR, final_filename)

    # 9) Save the entire JSON data (including the signature) to disk.
    with open(filepath, 'w', encoding='utf-8') as f:
        json.dump(data, f, indent=2)
    
    # 10) Return a success response
    return jsonify({
        "message": "Data received and verified successfully",
        "filename": final_filename
    }), 200

if __name__ == '__main__':
    app.run(host=HOST, port=PORT, debug=DEBUG)
